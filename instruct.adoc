= Edster web application

== Context

.État du répertoire courant
* jhipster project
* storybook initialisation

== Intégration de storybook dans le développement de edster

=== Problème : Comment intégrer storybook dans les itérations de développement d'ester ?

.Agent taches:
* Crée le fichier storybook_jhipster_integration.adoc.
* Rédige-moi au format asciidoc, un plan de recette pour l'intégration de storybook dans le cycle d'itération de développement d'edster.

== Intégration de Storybook dans le cycle de développement d'Edster

=== Objectif
Définir une approche méthodologique pour intégrer Storybook efficacement dans le processus de développement de l'application Edster.

=== Contexte
Storybook est un outil de développement d'interface utilisateur qui permet de créer et tester des composants React de manière isolée.

=== Étapes de la recette d'intégration

==== 1. Configuration initiale

===== 1.1 Installation de Storybook
* Exécuter la commande d'installation de Storybook dans le projet JHipster
* Configurer les paramètres spécifiques au projet Edster
* Vérifier la compatibilité avec l'architecture existante

===== 1.2 Structure des répertoires
* Créer un répertoire `.storybook` à la racine du projet
* Définir des configurations pour :
** `main.js` : configuration principale de Storybook
** `preview.js` : configuration globale des rendus
** `preview-head.html` : éléments à inclure dans l'en-tête HTML

==== 2. Développement des stories

===== 2.1 Conventions de nommage
* Nommer les fichiers de stories avec le suffixe `.stories.tsx`
* Placer les fichiers de stories à proximité des composants correspondants
* Suivre une structure claire : `[NomComposant].stories.tsx`

===== 2.2 Création des stories
* Documenter chaque variante de composant
* Inclure des props par défaut
* Gérer les états différents (actif, inactif, chargement, erreur)
* Utiliser des données mockées réalistes

==== 3. Intégration continue

===== 3.1 Scripts npm
* Ajouter des scripts dans `package.json` :
** `storybook:start` : lancement du serveur Storybook
** `storybook:build` : génération de la version statique
** `storybook:test` : exécution des tests de stories

===== 3.2 Configuration CI/CD
* Intégrer Storybook dans le pipeline de déploiement
* Générer et publier la documentation de composants
* Configurer des checks automatiques pour les nouveaux composants

==== 4. Workflow de développement

===== 4.1 Développement composant
. Créer un nouveau composant
. Développer la story correspondante
. Tester le composant dans Storybook
. Valider les différents états et interactions

===== 4.2 Revue de code
* Exiger des stories pour chaque nouveau composant
* Vérifier la couverture des états et des interactions
* Utiliser les stories comme documentation visuelle

==== 5. Bonnes pratiques

===== 5.1 Documentation
* Ajouter des commentaires explicatifs dans les stories
* Décrire le but et le contexte de chaque composant
* Mentionner les dépendances et les contraintes

===== 5.2 Maintenabilité
* Mettre à jour régulièrement les stories
* Refactorer en même temps que les composants
* Supprimer les stories obsolètes

==== 6. Outillage et tests

===== 6.1 Plugins recommandés
* Storybook Addons :
** `@storybook/addon-essentials`
** `@storybook/addon-interactions`
** `@storybook/testing-library`

===== 6.2 Tests
* Écrire des tests d'accessibilité
* Tester les interactions
* Vérifier la compatibilité inter-navigateurs

=== Conclusion
L'intégration de Storybook permettra d'améliorer la qualité, la documentation et la collaboration dans le développement des composants d'Edster.


== Figma to Storybook
Pour transcriber efficacement votre maquette Figma vers des composants Storybook, je vais vous proposer une approche méthodologique en plusieurs étapes :

1. Analyse préliminaire
- Examinez votre maquette Figma et identifiez :
* Les composants réutilisables
* Les différents états et variations
* Les propriétés de design (couleurs, typographies, espacements)

# Analyse préliminaire de la maquette Figma

## 1. Identification des composants réutilisables

### Critères de détection des composants
- **Répétitivité** : Éléments qui apparaissent plusieurs fois dans la maquette
- **Modularité** : Éléments pouvant être utilisés dans différents contextes
- **Indépendance** : Composants autonomes avec une fonction claire

### Types de composants à identifier
- Boutons (avec différents états)
- Champs de formulaire
- Cartes
- Éléments de navigation
- Icônes
- Éléments de liste
- Composants de mise en page

## 2. Analyse des variations et états

### États à documenter
- **Boutons** :
* État par défaut
* Survol (hover)
* Actif (active)
* Désactivé
* Chargement
* Avec/sans icône

- **Champs de formulaire** :
* État par défaut
* Focus
* Rempli
* Erreur
* Désactivé

- **Cartes/Composants** :
* État standard
* Sélectionné
* Survolé
* Avec/sans contenu

## 3. Extraction des propriétés de design

### Système de design
- **Couleurs** :
* Palette primaire
* Couleurs secondaires
* États (success, error, warning)
* Dégradés

- **Typographie** :
* Polices utilisées
* Tailles de texte
* Graisses
* Hauteurs de ligne
* Espacement des lettres

- **Espacements** :
* Grille de mise en page
* Marges internes/externes
* Gouttières
* Alignements

- **Dimensions** :
* Tailles standard des composants
* Largeurs/hauteurs
* Proportions
* Espacements responsives

## 4. Outils recommandés pour l'analyse

### Plugins Figma
- **Figma Tokens**
- **Design System Analyzer**
- **Inspect** (intégré à Figma)

### Captures et documentation
- Prenez des captures d'écran des composants
- Notez les spécifications techniques
- Créez un document de référence

## 5. Préparation pour Storybook

### Checklist de préparation
- [ ] Liste détaillée des composants
- [ ] Documentation des variations
- [ ] Extraction des tokens de design
- [ ] Annotations des comportements interactifs

## Exemple de fiche de composant

```
Composant : Bouton Principal
- Variantes :
  * Primaire
  * Secondaire
  * Désactivé
- Tailles :
  * Petit
  * Moyen
  * Grand
- États :
  * Défaut
  * Hover
  * Focus
  * Chargement
```


2. Préparation de l'environnement
- Installez les plugins Figma utiles :
* "Figma to React"
* "Design Tokens"
* "Figma Export"

# Préparation de l'environnement Figma-Storybook

## 1. Installations préliminaires

### Outils Figma
- **Plugins à installer**
* Figma to React
* Design Tokens
* Figma Export
* Inspect Plugin
* Storybook for Figma

### Outils de développement
- Node.js (version LTS)
- npm ou yarn
- React
- TypeScript
- Storybook

## 2. Configuration des plugins Figma

### Figma to React
- Fonctionnalités clés :
* Génération automatique de code React
* Extraction des propriétés de composants
* Conversion des styles

#### Étapes de configuration
1. Installer le plugin dans Figma
2. Sélectionner les composants à exporter
3. Configurer les options d'export :
- Langage (TypeScript recommandé)
- Style de composant (Functional Components)
- Gestion des props

### Design Tokens
- Objectif : Standardiser les valeurs de design

#### Extraction des tokens
- Couleurs
- Typographies
- Espacements
- Tailles
- Bordures
- Ombres

## 3. Configuration du projet

### Structure de projet recommandée
```
my-project/
├── src/
│   ├── components/
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   ├── Button.stories.tsx
│   │   │   └── Button.test.tsx
│   │   └── ...
├── .storybook/
│   ├── main.js
│   ├── preview.js
│   └── preview-head.html
└── figma-tokens/
    ├── colors.json
    ├── typography.json
    └── spacing.json
```

### Script d'installation
```bash
# Création du projet React
npx create-react-app my-project --template typescript

# Installation de Storybook
npx storybook@latest init

# Plugins complémentaires
npm install -D \
  @storybook/addon-essentials \
  @storybook/addon-interactions \
  @storybook/testing-library
```

## 4. Configuration des tokens de design

### Fichier de tokens exemple
```json
{
  "colors": {
    "primary": "#3498db",
    "secondary": "#2ecc71",
    "background": "#f4f4f4"
  },
  "typography": {
    "fontFamily": "Inter, sans-serif",
    "fontSize": {
      "small": "12px",
      "medium": "16px",
      "large": "24px"
    }
  }
}
```

## 5. Intégration des tokens

### Méthodes d'intégration
- Utilisation directe des JSON
- Conversion en variables CSS
- Création de fichiers de thème React

### Exemple d'utilisation
```typescript
import tokens from '../figma-tokens/design-tokens.json';

const theme = {
  colors: tokens.colors,
  typography: tokens.typography
};
```

## 6. Vérifications finales

### Checklist
- [ ] Plugins Figma installés
- [ ] Projet React configuré
- [ ] Storybook initialisé
- [ ] Tokens de design extraits
- [ ] Structure de projet établie
- [ ] Dépendances installées

## Conseils additionnels
- Maintenez une communication étroite entre designers et développeurs
- Automatisez l'extraction des tokens si possible
- Documentez chaque étape de la configuration


3. Extraction des tokens de design
- Générez les tokens de design :
* Couleurs
* Typographies
* Espacements
* Dimensions

= Extraction des tokens de design

== Objectif
Transformer les éléments de design de Figma en tokens réutilisables et standardisés pour le développement.

== 1. Préparation

=== 1.1 Outils nécessaires
* Plugin Figma Tokens
* Visual Studio Code
* Éditeur JSON

=== 1.2 Types de tokens à extraire
* Couleurs
* Typographie
* Espacements
* Dimensions
* États

== 2. Extraction des couleurs

=== 2.1 Identification des couleurs
* Couleurs primaires
* Couleurs secondaires
* États (hover, focus, disabled)
* Nuances et dégradés

.Exemple de structure JSON pour les couleurs
[source,json]
----
{
  "colors": {
    "primary": {
      "default": "#3498db",
      "hover": "#2980b9",
      "active": "#21618c"
    },
    "secondary": {
      "default": "#2ecc71",
      "hover": "#27ae60",
      "active": "#186a3b"
    },
    "neutral": {
      "100": "#f8f9fa",
      "200": "#e9ecef",
      "300": "#dee2e6"
    }
  }
}
----

== 3. Extraction de la typographie

=== 3.1 Éléments à capturer
* Familles de polices
* Tailles de police
* Graisses
* Hauteurs de ligne
* Espacement des lettres

.Exemple de structure JSON pour la typographie
[source,json]
----
{
  "typography": {
    "fontFamilies": {
      "primary": "Inter, sans-serif",
      "secondary": "Roboto, sans-serif"
    },
    "fontSizes": {
      "xs": "12px",
      "sm": "14px",
      "base": "16px",
      "lg": "18px",
      "xl": "24px"
    },
    "fontWeights": {
      "regular": 400,
      "medium": 500,
      "bold": 700
    },
    "lineHeights": {
      "tight": 1.2,
      "normal": 1.5,
      "relaxed": 1.8
    }
  }
}
----

== 4. Extraction des espacements

=== 4.1 Types d'espacements
* Marges internes
* Marges externes
* Gouttières de grille
* Espacements entre composants

.Exemple de structure JSON pour les espacements
[source,json]
----
{
  "spacing": {
    "xs": "4px",
    "sm": "8px",
    "md": "16px",
    "lg": "24px",
    "xl": "32px",
    "grid": {
      "gutter": "16px",
      "margin": "24px"
    }
  }
}
----

== 5. Extraction des dimensions

=== 5.1 Composants à mesurer
* Hauteurs de composants
* Largeurs standard
* Tailles d'icônes
* Rayons de bordure

.Exemple de structure JSON pour les dimensions
[source,json]
----
{
  "dimensions": {
    "components": {
      "button": {
        "height": {
          "sm": "32px",
          "md": "40px",
          "lg": "48px"
        },
        "borderRadius": "4px"
      },
      "input": {
        "height": {
          "sm": "32px",
          "md": "40px",
          "lg": "48px"
        }
      }
    },
    "icons": {
      "sm": "16px",
      "md": "24px",
      "lg": "32px"
    }
  }
}
----

== 6. Consolidation des tokens

=== 6.1 Fichier de configuration final
* Fusionner tous les tokens
* Vérifier la cohérence
* Ajouter des commentaires

.Exemple de fichier de tokens consolidé
[source,json]
----
{
  "colors": { ... },
  "typography": { ... },
  "spacing": { ... },
  "dimensions": { ... }
}
----

== 7. Intégration et utilisation

=== 7.1 Méthodes d'application
* Variables CSS
* Thèmes React
* Bibliothèques de design system

== Conclusion
L'extraction méthodique des tokens de design permet une cohérence et une réutilisabilité accrues dans le développement d'interface.

4. Création des composants React
- Traduisez chaque élément Figma en composant React
- Utilisez des bibliothèques comme Styled Components ou Tailwind
- Respectez la structure et les propriétés du design

= Création des composants React

== 1. Préparation méthodologique

=== 1.1 Principes fondamentaux
* Décomposition modulaire
* Respect de l'architecture de design
* Réutilisabilité maximale
* Séparation des responsabilités

=== 1.2 Structure de base d'un composant
[source,typescript]
----
import React from 'react';
import styled from 'styled-components';

interface [NomComposant]Props {
  // Définition des propriétés
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
}

const [NomComposant]Wrapper = styled.div<[NomComposant]Props>`
  // Styles basés sur les propriétés
  background-color: ${props =>
    props.disabled ? 'gray' :
    props.variant === 'primary' ? '#3498db' : '#2ecc71'};

  padding: ${props =>
    props.size === 'small' ? '8px 12px' :
    props.size === 'medium' ? '12px 16px' : '16px 24px'};
`;

export const [NomComposant]: React.FC<[NomComposant]Props> = ({
  variant = 'primary',
  size = 'medium',
  disabled = false,
  children,
  ...rest
}) => {
  return (
    <[NomComposant]Wrapper
      variant={variant}
      size={size}
      disabled={disabled}
      {...rest}
    >
      {children}
    </>
  );
};
----

== 2. Stratégies de conversion

=== 2.1 Analyse des composants Figma
* Identifier les propriétés variants
* Mapper les états
* Extraire les dimensions
* Capturer les interactions

=== 2.2 Techniques de transformation

==== Mapping des variants
[source,typescript]
----
type ButtonVariant = 'primary' | 'secondary' | 'tertiary';
type ButtonSize = 'small' | 'medium' | 'large';

interface ButtonProps {
  variant?: ButtonVariant;
  size?: ButtonSize;
  fullWidth?: boolean;
  disabled?: boolean;
}
----

==== Gestion des états
[source,typescript]
----
const getButtonStyles = (props: ButtonProps) => {
  const baseStyles = {
    primary: {
      default: '#3498db',
      hover: '#2980b9',
      active: '#21618c'
    },
    secondary: {
      default: '#2ecc71',
      hover: '#27ae60',
      active: '#186a3b'
    }
  };

  const currentVariant = baseStyles[props.variant || 'primary'];

  return {
    backgroundColor: props.disabled
      ? 'gray'
      : currentVariant.default,
    '&:hover': {
      backgroundColor: props.disabled
        ? 'gray'
        : currentVariant.hover
    }
  };
};
----

== 3. Gestion des tokens de design

=== 3.1 Intégration des tokens
[source,typescript]
----
import designTokens from '../tokens/design-tokens.json';

const theme = {
  colors: designTokens.colors,
  typography: designTokens.typography,
  spacing: designTokens.spacing
};

const Button = styled.button`
  font-family: ${theme.typography.fontFamilies.primary};
  color: ${theme.colors.primary.default};
  padding: ${theme.spacing.md};
`;
----

== 4. Bonnes pratiques

=== 4.1 Checklist de développement
* [ ] Respect de la maquette Figma
* [ ] Gestion des états
* [ ] Propriétés paramétrables
* [ ] Accessibilité
* [ ] Performance
* [ ] Tests unitaires

=== 4.2 Exemple de composant complet
[source,typescript]
----
export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'medium',
  children,
  disabled = false,
  ...props
}) => {
  return (
    <StyledButton
      $variant={variant}
      $size={size}
      disabled={disabled}
      {...props}
    >
      {children}
    </StyledButton>
  );
};

Button.displayName = 'Button';
----

== 5. Patterns avancés

=== 5.1 Composition de composants
* Utilisation de l'héritage
* Composition par props
* Injection de comportements

== Conclusion
La création de composants React nécessite une approche méthodique, en respectant les principes de design et de développement logiciel.


5. Création des stories Storybook
- Pour chaque composant :
* Créez un fichier `.stories.tsx`
* Documentez les différents états
* Utilisez les Storybook Controls

= Création des stories Storybook

== 1. Principes fondamentaux

=== 1.1 Objectifs des stories
* Documentation visuelle des composants
* Test des différents états et variations
* Facilitation de la revue de code
* Validation de l'interface utilisateur

=== 1.2 Structure de base d'une story
[source,typescript]
----
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

// Configuration du composant
const meta: Meta<typeof Button> = {
  title: 'Components/Button',
  component: Button,
  // Paramètres globaux
  parameters: {
    layout: 'centered',
  },
  // Définition des props par défaut
  args: {
    children: 'Button Text',
  },
  // Contrôles des propriétés
  argTypes: {
    variant: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'tertiary']
    },
    size: {
      control: { type: 'radio' },
      options: ['small', 'medium', 'large']
    }
  }
};
export default meta;

// Types de stories
type Story = StoryObj<typeof Button>;
----

== 2. Stratégies de création de stories

=== 2.1 Variations de base
[source,typescript]
----
export const Primary: Story = {
  args: {
    variant: 'primary',
    children: 'Primary Button'
  }
};

export const Secondary: Story = {
  args: {
    variant: 'secondary',
    children: 'Secondary Button'
  }
};

export const Disabled: Story = {
  args: {
    disabled: true,
    children: 'Disabled Button'
  }
};
----

=== 2.2 States complexes
[source,typescript]
----
export const WithIcon: Story = {
  args: {
    children: (
      <>
        <Icon name="download" />
        Download
      </>
    )
  }
};

export const Loading: Story = {
  args: {
    isLoading: true,
    children: 'Processing...'
  }
};
----

== 3. Techniques avancées

=== 3.1 Interactions
[source,typescript]
----
import { userEvent, waitFor, within } from '@storybook/testing-library';
import { expect } from '@storybook/jest';

export const ClickInteraction: Story = {
  play: async ({ args, canvasElement }) => {
    const canvas = within(canvasElement);
    const button = canvas.getByRole('button');

    await userEvent.click(button);

    await waitFor(() => {
      expect(args.onClick).toHaveBeenCalled();
    });
  }
};
----

=== 3.2 Accessibilité
[source,typescript]
----
export const Accessibility: Story = {
  parameters: {
    a11y: {
      // Configuration des tests d'accessibilité
      config: {
        rules: [
          {
            id: 'color-contrast',
            enabled: true
          }
        ]
      }
    }
  }
};
----

== 4. Documentation enrichie

=== 4.1 Utilisation des MDX
[source,mdx]
----
# Button Component

## Overview
Le composant Button permet de...

## Usage
```jsx
<Button variant="primary" size="medium">
  Click me
</Button>
```

## Variations
- Primary
- Secondary
- Disabled
----

== 5. Configuration globale

=== 5.1 Fichier de configuration Storybook
[source,javascript]
----
// .storybook/main.js
module.exports = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/addon-interactions',
    '@storybook/addon-a11y'
  ],
  framework: '@storybook/react'
};
----

== 6. Bonnes pratiques

=== 6.1 Checklist de création
* [ ] Couvrir tous les états du composant
* [ ] Tester les interactions
* [ ] Vérifier l'accessibilité
* [ ] Documenter l'utilisation
* [ ] Ajouter des exemples de code

== Conclusion
La création de stories Storybook permet une documentation vivante et interactive des composants, facilitant le développement et la collaboration.

== Jhipster to Storybook

Dans ce contexte, votre approche d'intégration de Storybook dans un projet JHipster existant nécessite quelques adaptations spécifiques. Voici une stratégie adaptée :

1. Compatibilité avec JHipster
- JHipster génère déjà une structure React
- Vous voulez conserver :
* Le système CSS existant
* Les composants React générés
* Les dépendances actuelles

2. Installation de Storybook
```bash
# Dans votre projet JHipster
npx storybook@latest init
```

3. Configuration du .storybook/main.js
```javascript
module.exports = {
  stories: [
    '../src/**/*.stories.@(js|jsx|ts|tsx)',
    // Inclure les stories des composants JHipster
  ],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/addon-interactions'
  ],
  framework: {
    name: '@storybook/react-webpack5',
    options: {}
  }
};
```

4. Stratégie pour les composants existants
- Créez des stories pour les composants JHipster
- Conservez les styles originaux
- Minimisez les modifications

Voulez-vous que je détaille l'une de ces étapes ou que je vous propose un plan d'action plus précis ?

=== Récuperation des composants Jhipster

Excellent point. Pour extraire des composants de Figma pour Edster sans se lier au CSS de Figma, je vous recommande une approche méthodologique :

1. Analyse des composants Figma
- Identifiez les composants essentiels pour Edster
- Extrayez leur structure et leur logique
- Ignorez délibérément le style graphique

2. Méthode d'extraction
- Utilisez le plugin "Figma to React"
- Générez un code React générique
- Adaptez les composants au système de design d'Edster

3. Points de focus
- Structure des composants
- Gestion des props
- Comportements interactifs
- Accessibilité

4. Exemple de transformation
```typescript
// Composant générique de Figma
const FigmaButton = ({ label, type }) => (
  <button
    className={`btn btn-${type}`}
    aria-label={label}
  >
    {label}
  </button>
);

// Adaptation pour Edster
const EdsterButton = ({
  label,
  variant = 'primary',
  onClick,
  disabled = false
}) => (
  <button
    className={`edster-btn edster-btn-${variant}`}
    onClick={onClick}
    disabled={disabled}
    aria-label={label}
  >
    {label}
  </button>
);
```

=== processus complet d'extraction
# Extraction méthodologique des composants de Figma

## 1. Préparation et analyse préliminaire

### 1.1 Étude des composants Figma
- Analyser chaque composant du point de vue fonctionnel
- Identifier :
* Structure logique
* Comportements interactifs
* États possibles
* Propriétés dynamiques

### 1.2 Outils nécessaires
- Plugin Figma "Inspect"
- Visual Studio Code
- React Developer Tools
- Extension React pour Figma

## 2. Méthode d'extraction systématique

### 2.1 Processus de transformation
1. Capture de la structure
2. Identification des props
3. Génération du code React
4. Adaptation au système de design d'Edster

### 2.2 Exemple détaillé : Extraction d'un bouton

#### Analyse du composant Figma
```typescript
// Analyse des propriétés du bouton Figma
interface FigmaButtonProperties {
  label: string;
  type: 'primary' | 'secondary' | 'tertiary';
  state: 'default' | 'hover' | 'disabled' | 'loading';
  icon?: string;
  size: 'small' | 'medium' | 'large';
}
```

#### Transformation en composant Edster
```typescript
import React from 'react';

// Types spécifiques à Edster
type EdsterButtonVariant = 'primary' | 'secondary' | 'tertiary';
type EdsterButtonSize = 'small' | 'medium' | 'large';

// Interface des props adaptée à Edster
interface EdsterButtonProps {
  label: string;
  variant?: EdsterButtonVariant;
  size?: EdsterButtonSize;
  disabled?: boolean;
  loading?: boolean;
  onClick?: () => void;
  icon?: React.ReactNode;
}

// Composant Edster
const EdsterButton: React.FC<EdsterButtonProps> = ({
  label,
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  onClick,
  icon: Icon
}) => {
  const handleClick = () => {
    if (!disabled && !loading && onClick) {
      onClick();
    }
  };

  return (
    <button
      className={`edster-btn edster-btn-${variant} edster-btn-${size}`}
      disabled={disabled || loading}
      onClick={handleClick}
      aria-label={label}
      aria-busy={loading}
    >
      {loading ? (
        <span className="edster-btn-loader">Chargement...</span>
      ) : (
        <>
          {Icon && <span className="edster-btn-icon">{Icon}</span>}
          <span className="edster-btn-label">{label}</span>
        </>
      )}
    </button>
  );
};

export default EdsterButton;
```

## 3. Stratégies d'adaptation

### 3.1 Gestion des différences
- Ignorer les styles CSS de Figma
- Réimplémenter les comportements
- Adapter aux conventions d'Edster
- Ajouter des fonctionnalités spécifiques

### 3.2 Principes de transformation
1. Garder la structure logique
2. Adapter les noms de props
3. Implémenter les états
4. Ajouter l'accessibilité
5. Respecter les conventions React d'Edster

## 4. Processus de validation

### 4.1 Checklist de vérification
- [ ] Structure logique préservée
- [ ] Props correctement mappées
- [ ] États gérés
- [ ] Accessibilité implémentée
- [ ] Conventions de nommage respectées

### 4.2 Tests recommandés
```typescript
import { render, fireEvent } from '@testing-library/react';

describe('EdsterButton', () => {
  it('rend correctement le bouton', () => {
    const { getByText } = render(
      <EdsterButton label="Valider" />
    );
    expect(getByText('Valider')).toBeInTheDocument();
  });

  it('gère le clic', () => {
    const mockOnClick = jest.fn();
    const { getByText } = render(
      <EdsterButton
        label="Valider"
        onClick={mockOnClick}
      />
    );

    fireEvent.click(getByText('Valider'));
    expect(mockOnClick).toHaveBeenCalledTimes(1);
  });

  it('désactive le bouton', () => {
    const { getByText } = render(
      <EdsterButton
        label="Valider"
        disabled
      />
    );

    expect(getByText('Valider')).toBeDisabled();
  });
});
```

## 5. Intégration avec JHipster

### 5.1 Considérations
- Conserver la structure React existante
- Ajouter les nouveaux composants
- Minimiser les perturbations

## Conclusion
L'extraction de composants de Figma nécessite une approche méthodique, en se concentrant sur la logique plutôt que sur le style visuel.

